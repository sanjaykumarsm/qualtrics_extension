#!/usr/bin/env bash

BEE_VERSION=1.0.7
FMT_YELLOW="\e[33m"
FMT_CYAN="\e[36m"
FMT_RED="\e[91m"
FMT_GREEN="\e[32m"
FMT_RESET="\e[0m"

cd "$(dirname "$0")" || exit 1

save () {
    # See: http://www.etalabs.net/sh_tricks.html
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    printf " "
}

rand() {
    LC_CTYPE=C tr -dc '[:digit:]' </dev/urandom | head -c 8
}

# Prints basic usage instructions for bee
print_usage() {
    printf "\\n"
    printf "Bee executes builds in a consistent environment (docker)\\n"
    printf "For documentation go to https://gitlab-app.eng.qops.net/core/bee\\n"
    printf "\\n"
    printf "${FMT_YELLOW}Usage${FMT_RESET}:\\n"
    printf "  bee [OPTIONS] <BEE COMMAND|BUILD COMMAND>\\n"
    printf "  Note that all unrecognized options are treated as build commands and passed through to the underlying \\n"
    printf "  build container. All options intended for bee have to be positioned before build arguments.\\n"
    printf "\\n"
    printf "${FMT_YELLOW}Bee Options${FMT_RESET}:\\n"
    printf "  -dc|--run-docker-compose\\n"
    printf "    Will start the docker-compose file if it is present. After build will stop the file\\n"
    printf "  -p|--purge\\n"
    printf "    Will purge all cached state prior to build\\n"
    printf "  -trs|--report-test-results\\n"
    printf "    After the build invocation, this option will attempt to upload test results (if present)\\n"
    printf "    to the TRS service for historical reporting\\n"
    printf "\\n"
    printf "${FMT_YELLOW}Bee Commands${FMT_RESET}:\\n"
    printf "  qamel\\n"
    printf "    Is a thin wrapper around the qamel API for interactions with Nomad (e.g. deployment).\\n"
    printf "    Contrary to qamel-driver, this adds full support for continuous deployment, i.e. this works\\n"
    printf "    in Jenkins. Note that all job definitions are expected in the .qamel directory. See the bee \\n"
    printf "    documentation for additional information.\\n"
    printf "\\n"
    printf "  config\\n"
    printf "    Will resolve values for all provided configuration names. For example, to find out the bee\\n"
    printf "    build name, run 'bee config NAME'\\n"
}

# Prints the given variable names in name=value format. One variable per line.
# If the variable does not exist the value will be empty, but the name= still printed.
# If the variable name does not exist, the line will be skipped.
print_config() {
    for k in "${@}"; do
        val="$(echo ${!k})"
        printf "%s=%s\\n" "${k}" "${val}"
    done
}

# Imports all settings by first loading all environment variables with BEE_ prefix into the local variable space.
# If a .bee file is present, variables are then loaded from this file overriding all previously set variables.
import_setting() {
    l_name="${1}"
    # Initialize the setting
    eval "${l_name}="

    # Attempt to load it from the environment
    l_env_name="BEE_${l_name}"
    if [[ -n "${l_env_name}" ]]; then
        eval "${l_name}=\"\$${l_env_name}\""
    fi

    # Attempt to override it from the .bee file
    if [[ -f .bee ]]; then
        while read LINE; do
            case ${LINE} in ${l_name}=*)
                eval "${LINE}"
                break
            esac
        done < .bee
    fi
}

# Imports all environment variables with the BEE_ prefix into the scripts environment space.
import_environment() {
    l_fifo="${TMPDIR:-/tmp}/$$.$(rand)"
    mkfifo "${l_fifo}"
    env > "${l_fifo}" &
    while IFS='=' read -r name value
    do
        name_suffix=${name#BEE_}
        if [[ ${#name} -gt ${#name_suffix} ]]; then
            eval "${name_suffix}=\"${value}\""
        fi
    done < "${l_fifo}"
    rm "${l_fifo}"
}

# Ensures that docker is installed and running when executing in container mode.
assert_dependencies() {
    command -v docker > /dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        printf "${FMT_RED}ERROR${FMT_RESET}: Docker is not installed or could not be found!\\n"
        exit 1
    else
        docker ps > /dev/null 2>&1
        if [[ $? -ne 0 ]]; then
              printf "${FMT_RED}ERROR${FMT_RESET}: Docker installed but not running!\\n"
              exit 1
        fi
    fi

    command -v jq > /dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        printf "${FMT_RED}ERROR{$FMT_RESET}: JQ is required but could not be found.\\n"
        printf "  Try 'brew install jq'\\n"
        exit 1
    fi
}

# Clears all bee related docker state
docker_clear_state() {
    RUNNING_CONTAINERS=$(docker ps | grep "${DOCKER_INSTANCE_NAME}")
    if [[ -n "${RUNNING_CONTAINERS}" ]]; then
        printf "Killing running bee containers\\n"
        docker kill "${DOCKER_INSTANCE_NAME}"
    fi

    docker rm -f $(docker ps -aqf name="${DOCKER_INSTANCE_NAME}") &> /dev/null
}

# Runs setup steps (if specified) in the docker container and saves the state as a new image
docker_run_setup() {
    if [[ -z "${CONTAINER_SETUP_SCRIPT}" ]]; then
        return
    fi

    SETUP_IMAGE="bee_${DOCKER_CONTAINER_NAME}_setup_cached"
    if [[ -n ${CONTAINER_SETUP_FORCE_REBUILD} || "$(docker images -q ${SETUP_IMAGE} 2> /dev/null)" == "" ]]; then
        BUILD_CMD="docker run --name '${DOCKER_INSTANCE_NAME}_setup' \
            ${DOCKER_ENVIRONMENT} \
            -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}:${CONTAINER_WORKSPACE}' \
            -v '${ABSOLUTE_ROOT_PATH}${HOST_CACHE_PATH}:${CONTAINER_CACHE_PATH}' \
            -w '${CONTAINER_WORKSPACE}' \
            '${DOCKER_IMAGE}' \
            ${CONTAINER_SETUP_SCRIPT}"

        printf "Setting up docker container: %s\\n" "${BUILD_CMD}"
        eval "${BUILD_CMD}" || exit 1
        container_id=$(docker ps -aqf "name=${DOCKER_INSTANCE_NAME}_setup")

        printf "Saving state of docker container %s as %s%s\\n" "${container_id}" "${SETUP_IMAGE}"
        docker commit "${container_id}" "${SETUP_IMAGE}" || exit 1
    else
        printf "\\n${FMT_YELLOW}WARNING${FMT_RESET}: Using cached version of container with setup script applied."
        printf "\\n      Use the '--purge' flag to rebuild this container\\n\\n" "${SETUP_IMAGE}"
    fi

    # Use this image for the remainder of the bee invocation
    DOCKER_IMAGE="${SETUP_IMAGE}"
}

docker_clear_setup() {
    SETUP_IMAGE="bee_${DOCKER_CONTAINER_NAME}_setup_cached"
    docker rmi -f $(docker images -qf reference="${SETUP_IMAGE}") &> /dev/null
}

# Attempts to resolve the local machine public IP address. This may not work consistently if multiple inet interfaces
# are present.
determine_ip_address() {
    import_setting 'HOST_IP'
    if [[ -z "${HOST_IP}" ]]; then
        if hostname -i  > /dev/null 2>&1; then
            HOST_IP=$(hostname -i)
        elif command -v ip > /dev/null 2>&1; then
            HOST_IP=$(ip route get 1 | awk '{print $NF;exit}')
        elif command -v ifconfig > /dev/null 2>&1; then
            HOST_IP=$(ifconfig | awk '/inet / && $2 != "127.0.0.1"{print $2}' | head -n 1)
        else
            printf "${FMT_RED}ERROR${FMT_RESET}: Unable to determine local ip address!\\n"
            exit 1
        fi
    fi
}

# Determines the means to communicate by with the docker daemon
determine_docker_comm() {
    if [[ -n "${DOCKER_COMM}" ]]; then
        return 0
    fi

    if [[ -S "/var/run/docker.sock" ]]; then
        DOCKER_COMM="-v '/var/run/docker.sock:/var/run/docker.sock'"
    elif [[ -n "${DOCKER_HOST}" ]]; then
        DOCKER_COMM="${DOCKER_COMM} -e 'DOCKER_HOST=${DOCKER_HOST}'"
    else
        return 1
    fi
}

# Determines the host caching directory and the mapping to the container level.
# If running in native mode these are equal.
detect_host_cache_path() {
    import_setting 'HOST_CACHE_PATH'
    if [[ -z "${HOST_CACHE_PATH}" ]]; then
        if [[ "$(uname)" = "Darwin" ]]; then
            HOST_CACHE_PATH="/private/var/tmp/bee.cache"
        else
            HOST_CACHE_PATH="/var/tmp/bee.cache"
        fi
    fi

    if [[ ! -d "${HOST_CACHE_PATH}" ]]; then
        mkdir -p "${HOST_CACHE_PATH}"
    fi
}

# Checks for updated versions of the invoker script (this)
check_for_updates() {
    BEE_INSTALL="http://artifactory.eng.qops.net:8081/artifactory/deployment-tools/core-platform/bee/install"
    command -v curl > /dev/null 2>&1
    if [[ $? -eq 0 ]]; then
        curl -s "${BEE_INSTALL}" --silent --location --connect-timeout 1 --max-time 1 | sh /dev/stdin test
    fi
}

# After explicit imports of settings above we can import the remaining settings. First, we apply settings set globally
# through environment variables, and then override those using the local .bee file.
load_all_settings() {
    import_environment
    if [[ -f ".bee" ]]; then
        . ".bee"
    fi

    # Load viariables with `ENV_` prefix
    for e in ${!ENV_@}; do
        BUILD_ENVIRONMENT="${BUILD_ENVIRONMENT} ${e#"ENV_"}=\"${!e}\""
    done

    # Load certain additional environment variables
    BUILD_ENVIRONMENT="${BUILD_ENVIRONMENT} BUILD_TOOL=\"${BUILD_TOOL}\""
    for e in ${!BUILD_ALIAS_@}; do
        BUILD_ENVIRONMENT="${BUILD_ENVIRONMENT} ${e}=\"${!e}\""
    done
}

# Maps from detection file to the respective technology and container version. This should be updated each time
# a new technology is added or the container is updated.
detect_build_tech() {
    if [[ -f "pom.xml" ]]; then
        BUILD_TECH="maven"
        BUILD_TECH_VER="0.2.2"
    elif [[ -f "package.json" ]]; then
        BUILD_TECH="yarn"
        BUILD_TECH_VER="0.2.3"
    elif [[ -f "go.mod" ]]; then
        BUILD_TECH="golang"
        BUILD_TECH_VER="0.2.4"
    elif [[ -f "composer.json" ]]; then
        BUILD_TECH="composer"
        BUILD_TECH_VER="0.1.0"
    elif [[ -f "build.py" ]]; then
        BUILD_TECH="pyb"
        BUILD_TECH_VER="0.2.1"
    elif [[ -f "build.sbt" ]]; then
        BUILD_TECH="sbt"
        BUILD_TECH_VER="0.2.1"
    elif [[ -f "build.gradle" ]] || [[ -f "build.gradle.kts" ]]; then
        BUILD_TECH="gradle"
        BUILD_TECH_VER="0.2.0"
    else
        printf "${FMT_RED}ERROR${FMT_RESET}: Unable to detect build technology!"
        exit 1
    fi
}

append_paths() {
    path=$2
    # Ensure $1 if set ends in a slash
    if [[ ! "X${1}" = "X" ]]; then
        if [[ "${1%/}" = "${1}" ]]; then
            path="${1}/${2}"
        else
            path="${1}${2}"
        fi
    fi

    echo "${path}"
}

# Detects the user that is invoking the bee script
detect_user() {
    if [[ -n "${BEE_USER}" ]]; then
        local_user="${BEE_USER}"
    elif [[ "$(whoami)" != "" ]]; then
        local_user="$(whoami)"
    elif [[ -n "${USER}" ]]; then
        local_user="${USER}"
    else
        printf "${FMT_RED}ERROR${FMT_RESET}: Unable to detect user to be used!\\n"
        exit 1
    fi

    DOCKER_USER="${local_user}"
    DOCKER_USER_ID=$(id -u "${local_user}")
    DOCKER_GROUP=$(id -g -n "${local_user}")
    DOCKER_GROUP_ID=$(id -g "${local_user}")
}

# Invokes docker-compose commands. This is done in a docker container which is guaranteed to have docker-compose
# installed.
docker_compose() {
    work_dir="/bee_${BUILD_ID}"
    mnt_dir="-v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}:${work_dir}'"
    env="-e 'ABSOLUTE_WORKSPACE=${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}' -e 'CONTAINER_NETWORK=${CONTAINER_NETWORK}'"
    container="${DOCKER_REGISTRY}/core-platform/bee-base-alpine:0.2.3"
    cmd="docker run --rm --net=host ${DOCKER_COMM} ${mnt_dir} ${env} -w '${work_dir}' ${container} docker-compose $*"
    eval "${cmd}"
}


# Stops previously launched docker containers.
docker_stop_dependencies() {
    ret=$?
    docker_compose down
    exit ${ret}
}

# If a docker compose file is present, will start the associated containers and configure the build container to
# join that network.
docker_start_dependencies() {
    if [[ ! -f "${DOCKER_COMPOSE_FILE}" ]]; then
        return
    fi

    if [[ -z "${CONTAINER_NETWORK}" ]]; then
        # By default, docker-compose will start all containers on a network named pwd_default
        # To guarantee non-conflicting parallel builds we should set a custom network
        CONTAINER_NETWORK="bee_${BUILD_ID}_default"
    fi

    trap docker_stop_dependencies EXIT
    docker_compose up -d
    if [[ "${?}" != "0" ]]; then
        printf "ERROR: Failed to start dependency containers\\n"
        exit 1
    fi

    if [[ -z "${DOCKER_COMM_OVERRIDE}" ]]; then
        # When running in the docker-compose generated network we can no longer access docker via
        # the DOCKER_HOST setting (if used). As such the best we can hope for is that mounting in the docker
        # socket will work. In practice it seems to.
        printf "\n${FMT_YELLOW}WARNING${FMT_RESET}: DOCKER_COMM will be overwritten to use docker socket\n\n"
        DOCKER_COMM_OVERRIDE="-v '/var/run/docker.sock:/var/run/docker.sock'"
    fi
}

 test_result_upload() {
    if [[ -n "${TRS_DC}" ]]; then
        dc_env="-e 'ENVIRONMENT=${TRS_DC}'"
    fi

    ret_code=0
    if [[ -n "${TRS_UNIT_REPORT_RESULTS}" ]]; then

        printf "\\nAttempting to send unit test results via TRS uploader\\n"
        if [[ -n "${TRS_UNIT_COVERAGE_TYPE}" ]]; then
            unit_coverage_env="-e 'CODE_COVERAGE_REPORT_TYPE=${TRS_UNIT_COVERAGE_TYPE}' -e 'CODE_COVERAGE_FILE_PATH=${TRS_UNIT_COVERAGE_RESULTS}'"
            unit_coverage_env="${unit_coverage_env} -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}/${TRS_UNIT_COVERAGE_RESULTS}:/home/node/${TRS_UNIT_COVERAGE_RESULTS}'"
        fi

        if [[ "${TRS_UNIT_REPORT_TYPE}" == "GO" ]]; then
            base64 "./${TRS_UNIT_REPORT_RESULTS}" > "./${TRS_UNIT_REPORT_RESULTS}-tmp"
            mv "./${TRS_UNIT_REPORT_RESULTS}-tmp" "./${TRS_UNIT_REPORT_RESULTS}"
        fi

        if [[ -n "${TRS_UNIT_REPORT_IS_JUNIT_DIR}" && "${TRS_UNIT_REPORT_IS_JUNIT_DIR}" == "true" ]]; then
            unit_is_junit_dir_flag="-e 'JUNIT_DIRECTORY=true'"
        fi

        UPLOAD_CMD="docker run --rm \
            -e TEAM_NAME_TAG='${TRS_TEAM_TAG}' -e SERVICE_NAME_TAG='${TRS_SERVICE_TAG}' -e TEST_TYPE_TAG='unittests' \
            -e LANGUAGE_TAG='${TRS_LANGUAGE_TAG}' -e BUILD_NAME_TAG='${TRS_BUILD_TAG}' \
            -e REPORT_TYPE='${TRS_UNIT_REPORT_TYPE}' \
            -e REPORT_FILE_PATH='${TRS_UNIT_REPORT_RESULTS}' \
            -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}/${TRS_UNIT_REPORT_RESULTS}:/home/node/${TRS_UNIT_REPORT_RESULTS}' \
            ${dc_env} ${unit_coverage_env} ${unit_is_junit_dir_flag} \
            registry-app.eng.qops.net:5001/test-tools/trs-uploader:latest"

        printf "Executing TRS uploader with '%s'\\n" "${UPLOAD_CMD}"
        eval "${UPLOAD_CMD}" || ret_code=${?}
    else
        printf "\\nTRS_UNIT_REPORT_RESULTS path not set; skipping unit test results upload\\n"
    fi

    if [[ -n "${TRS_INTEGRATION_REPORT_RESULTS}" ]]; then

        printf "\\nAttempting to send integration test results via TRS uploader\\n"
        if [[ -n "${TRS_INTEGRATION_COVERAGE_TYPE}" ]]; then
            integration_coverage_env="-e 'CODE_COVERAGE_REPORT_TYPE=${TRS_INTEGRATION_COVERAGE_TYPE}' -e 'CODE_COVERAGE_FILE_PATH=${TRS_INTEGRATION_COVERAGE_RESULTS}'"
            integration_coverage_env="${integration_coverage_env} -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}/${TRS_INTEGRATION_COVERAGE_RESULTS}:/home/node/${TRS_INTEGRATION_COVERAGE_RESULTS}'"
        fi

        if [[ -n "${TRS_INTEGRATION_REPORT_IS_JUNIT_DIR}" && "${TRS_INTEGRATION_REPORT_IS_JUNIT_DIR}" == "true" ]]; then
            integration_is_junit_dir_flag="-e 'JUNIT_DIRECTORY=true'"
        fi

        UPLOAD_CMD="docker run --rm \
            -e TEAM_NAME_TAG='${TRS_TEAM_TAG}' -e SERVICE_NAME_TAG='${TRS_SERVICE_TAG}' -e TEST_TYPE_TAG='integrationtests' \
            -e LANGUAGE_TAG='${TRS_LANGUAGE_TAG}' -e BUILD_NAME_TAG='${TRS_BUILD_TAG}' \
            -e REPORT_TYPE='${TRS_INTEGRATION_REPORT_TYPE}' \
            -e REPORT_FILE_PATH='${TRS_INTEGRATION_REPORT_RESULTS}' \
            -e REPORT_CONFIG_ID='${TRS_CONFIG_ID}' \
            -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}/${TRS_INTEGRATION_REPORT_RESULTS}:/home/node/${TRS_INTEGRATION_REPORT_RESULTS}' \
            ${dc_env} ${integration_coverage_env} ${integration_is_junit_dir_flag} \
            registry-app.eng.qops.net:5001/test-tools/trs-uploader:latest"

        printf "Executing TRS uploader with '%s'\\n" "${UPLOAD_CMD}"
        eval "${UPLOAD_CMD}" || ret_code=${?}
    else
        printf "\\nTRS_INTEGRATION_REPORT_RESULTS path not set; skipping integration test results upload\\n"
    fi

    return "${ret_code}"
 }

qamel() {
    if [[ ! -d ".qamel" ]]; then
        printf "${FMT_RED}ERROR: Unable to find .qamel directory in %s${FMT_RESET}\\n" "$(pwd)"
        return 1
    fi

    if [[ -z "${QAMEL_PROJECT_ID}" ]]; then
        printf "${FMT_RED}ERROR: Unable to determine Git project id. Make sure QAMEL_PROJECT_ID is set.\\n${FMT_RESET}"
        return 1
    fi

    QAMEL_SCM_PAT="${QAMEL_SCM_PAT:-}"
    QAMEL_DRIVER_ACCESS_TOKEN=
    QAMEL_CACHE_PATH="${HOST_CACHE_PATH}/qamel"
    QAMEL_PROJECT_BRANCH="${QAMEL_PROJECT_BRANCH:-master}"
    QAMEL_SETTINGS_PATH="${QAMEL_CACHE_PATH}/.settings"
    QAMEL_EXPECT_PC_TICKET="${QAMEL_EXPECT_PC_TICKET:-false}"
    QAMEL_AWAIT_DEPLOYMENT="${QAMEL_AWAIT_DEPLOYMENT:-false}"

    mkdir -p "${QAMEL_CACHE_PATH}"
    if [[ -f "${QAMEL_SETTINGS_PATH}" ]]; then
        source "${QAMEL_SETTINGS_PATH}"
    fi

    if [[ -z "${QAMEL_LDAP_USERNAME}" ]]; then
        if ! tty -s; then
            printf "${FMT_RED}ERROR: QAMEL_LDAP_USERNAME not set${FMT_RESET}\\n"
            return 1
        fi

        confirm=n
        while [[ "${confirm}" != "y" ]]; do
            printf "${FMT_YELLOW}Please enter your LDAP username: ${FMT_RESET}"
            read -r QAMEL_LDAP_USERNAME
            printf "${FMT_YELLOW}LDAP username to be cached is '${QAMEL_LDAP_USERNAME}'. Correct [y/n]? ${FMT_RESET}"
            read -r confirm
        done

        echo "QAMEL_LDAP_USERNAME=${QAMEL_LDAP_USERNAME}" >> "${QAMEL_SETTINGS_PATH}"
        printf "Username was cached in ${QAMEL_SETTINGS_PATH}. Delete this file to be prompted again.\\n"
    fi

    qamel_driver_arguments=()
    while true; do
        if [[ -f "${1}" ]]; then
            qamel_files=(${@})
            qamel_files[0]="${1}"
            break
        elif [[ -d ".qamel/${1}" && -f ".qamel/${1}/${1}.yaml" ]]; then
            qamel_files=(${@})
            qamel_files[0]=".qamel/${1}/${1}.yaml"
            break
        elif [[ -f ".qamel/${1}.yaml" ]]; then
            qamel_files=(${@})
            qamel_files[0]=".qamel/${1}.yaml"
            break
        else
            qamel_driver_arguments+=("${1}")
        fi

        shift || break
    done

    len=${#qamel_files[@]}
    if [[ "${len}" == "0" ]]; then
        printf "${FMT_RED}ERROR: You must specify valid qamel file names that are present in the '.qamel' directory.\\n${FMT_RESET}"
        return 1
    fi

    if [[ "${#qamel_driver_arguments[@]}" == "0" ]]; then
        printf "${FMT_RED}ERROR: You must specify a qamel-driver action such as 'submit-job'${FMT_RESET}\\n"
        return 1
    fi

    job_dir="$(dirname ${qamel_files[0]})"
    for (( i=0; i<${len}; i++ )); do
        curr="${qamel_files[$i]}"
        if [[ ! -f "${curr}" ]]; then
            candidate=$(find -f ${job_dir}/**/${curr}*)
            if [[ ! -f "${candidate}" ]]; then
                printf "${FMT_RED}ERROR: Unable to find job file for '%s'!\\n" "${curr}"
                printf "  Found candidate(s): %s\\n" "${candidate}"
                return 1
            else
                curr="${candidate}"
            fi
        fi

        if [[ "${QAMEL_PROJECT_BRANCH}" != "local" ]]; then
            gitReference="gitlab:yaml:${QAMEL_PROJECT_ID}:${QAMEL_PROJECT_BRANCH}:"
        fi

        if tty -s && [[ "${curr}" == *"gov1"* ]]; then
            printf "${FMT_YELLOW}Detected gov1 file. Deploy using tunnel to gov1? [y/n]:${FMT_RESET} "
            read -r confirm
            if [[ "${confirm}" == "y" ]]; then
                QAMEL_GOV1_TUNNEL="true"
            fi
        fi

        qamel_files[$i]="${gitReference}${curr}"
    done

    if tty -s; then
        printf "${FMT_YELLOW}Confirm %s %s [y/n]? ${FMT_RESET}" "${qamel_driver_arguments[*]}" "${qamel_files[*]}"
        read -r confirm
        if [[ "${confirm}" != "y" ]]; then
            return 0
        fi
    fi

    if [[ -n "${QAMEL_DRIVER_ACCESS_TOKEN}" ]]; then
        qd_docker="${qd_docker} -e QAMEL_DRIVER_ACCESS_TOKEN"
        qd_arg="${qd_arg} --access-token-from-environment"
    fi

    if [[ "${QAMEL_PROJECT_BRANCH}" == "local" ]]; then
        qd_action_arg="${qd_action_arg} --use-local-files"
    elif [[ -n "${QAMEL_SCM_PAT}" ]]; then
        qd_docker="${qd_docker} -e QAMEL_SCM_PAT"
        qd_action_arg="${qd_action_arg} --scm-pat-from-environment"
    fi

    if tty -s; then
        qd_docker="-it ${qd_docker}"
    fi

    if [[ "${QAMEL_GOV1_TUNNEL}" == "true" ]]; then
        ssh -f -o ExitOnForwardFailure=yes -L 9999:qamel-driver.service.gov1.consul:443 gov1 sleep 30
        ssh_ret="${?}"
        if [[ "${ssh_ret}" != "0" ]]; then
            printf "${FMT_RED}ERROR:${FMT_RESET} Unable to establish tunnel (%s)\\n" "${ssh_ret}"
            exit ${ssh_ret}
        fi

        qd_arg="${qd_arg} -H host.docker.internal -P 9999"
    fi

    [[ -z "${XDG_CACHE_HOME}" ]] && XDG_CACHE_HOME="${HOME}/.cache"
    qd_cache_path="${XDG_CACHE_HOME}/qamel-driver"
    [[ ! -d "${qd_cache_path}" ]] && mkdir -p "${qd_cache_path}"

    QAMEL_DOCKER_IMAGE_PATH="${QAMEL_DOCKER_IMAGE_PATH:-registry-app.eng.qops.net:5001/dtool/qamel-driver:latest}"
    qamel_driver_cmd="docker run \
        ${qd_docker} \
        -e USER=${QAMEL_LDAP_USERNAME} \
        -e 'HOME=/home' \
        -v ${qd_cache_path}:/home/.cache/qamel-driver \
        -v $(pwd):/mnt/cwd:ro \
        -v /tmp:/tmp/qdout \
        --rm \
        ${QAMEL_DOCKER_IMAGE_PATH} \
        ${qd_arg} \
        --verbose-response \
        --verbose-response-format JSON \
        --verbose-response-destination /tmp/qdout/qd.json \
        ${qamel_driver_arguments[*]} \
        ${qd_action_arg} \
        --restricted-variable DEPLOY_DATE:'$(date)' \
        --restricted-variable JIRA_USER:'${QAMEL_LDAP_USERNAME}' \
        ${qamel_files[*]}"

    printf "%s\\n" "${qamel_driver_cmd}"
    eval "${qamel_driver_cmd}"
    qamel_driver_ret=$?
    if [[ "${qamel_driver_ret}" != "0" ]]; then
        printf "${FMT_RED}ERROR: Deployment failed (%d) ${FMT_RESET}\\n" "${qamel_driver_ret}"
        return ${qamel_driver_ret}
    fi

    printf "${FMT_GREEN}OK: qamel executed command (%s)${FMT_RESET}\\n" "${qamel_driver_ret}"
    qamel_driver_response="/tmp/qd.json"
    if [[ ! -f "${qamel_driver_response}" ]]; then
        printf "${FMT_RED}ERROR: Unable to find qamel-driver output${FMT_RESET}\\n"
        return 1
    fi

    qamel_region="$(jq -r '."job-spec".job.region' /tmp/qd.json)"
    nomad_base_url="https://nomad-ssl.service.${qamel_region}.consul:4646"
    if [[ "${QAMEL_EXPECT_PC_TICKET}" == "true" ]]; then
        printf "${FMT_YELLOW}Expecting PC ticket${FMT_RESET}\\n"
        cm_response=$(jq -r '.["cm-response"]' ${qamel_driver_response})
        pc_ticket_id=$(echo "${cm_response}" | jq -r '.["pc-ticket-id"]')
        if [[ "${pc_ticket_id}" == "" || "${pc_ticket_id}" == "null" ]]; then
            printf "${FMT_RED}ERROR: Unable to find PC Ticket ID${FMT_RESET}\\n"
            return 1
        else
            printf "${FMT_YELLOW}PC ticket id: %s${FMT_RESET}\\n" "${pc_ticket_id}."
            return 0
        fi
    fi

    if [[ "${QAMEL_AWAIT_DEPLOYMENT}" == "true" ]]; then
        printf "${FMT_YELLOW}Awaiting deployment${FMT_RESET}\\n"
        nomad_response=$(jq -r '.["orch-response"]' ${qamel_driver_response})
        evaluation_id=$(echo "${nomad_response}" | jq -j .EvalID)
        if [[ "${evaluation_id}" == "null" || "${evaluation_id}" == "" ]]; then
            printf "${FMT_RED}ERROR: Unable to find evaluation ID${FMT_RESET}\\n"
            return 1
        fi

        i="0"
        deployment_id=""
        printf "Evaluation id is: %s\\n" "${evaluation_id}"
        printf "${FMT_YELLOW}Waiting up to 5 minutes for deployment to succeed...${FMT_RESET}\\n"
        while [[ ${i} -lt 30 ]]; do
            if [[ "${deployment_id}" == "" || "${deployment_id}" == "null" ]]; then
                deployment_id=$(curl -s -k "${nomad_base_url}/v1/evaluation/${evaluation_id}" | jq -j .DeploymentID | xargs)
                if [[ "${deployment_id}" != "" && "${deployment_id}" != "null" ]]; then
                    printf "Deployment id is %s\\n" "${deployment_id}"
                fi
            fi

            if [[ "${deployment_id}" != "" && "${deployment_id}" != "null" ]]; then
                deployment_state=$(curl -s -k "${nomad_base_url}/v1/deployment/${deployment_id}" | jq -j .Status | xargs)
                if [[ "${deployment_state}" == "successful" ]]; then
                    printf "${FMT_GREEN}Deployment successful${FMT_RESET}\\n"
                    return 0
                elif [[ "${deployment_state}" == "failed" ]]; then
                    printf "${FMT_RED}Deployment failed${FMT_RESET}\\n"
                    return 1
                else
                    printf "Deployment is %s\\n" "${deployment_state}"
                fi
            fi

            sleep 10
            i=$((i+1))
        done

        printf "${FMT_RED}ERROR: Timeout while waiting for deployment to succeed${FMT_RESET}\\n"
        return 1
    fi
}

# Set default configuration
if [ -z "${BUILD_ID}" ]; then
    BUILD_ID="$(rand)"
fi
ARGS_ARRAY=$(save "$@")
DOCKER_REGISTRY="registry-app.eng.qops.net:5001"
DOCKER_IMAGE=
DOCKER_COMPOSE_FILE="${DOCKER_COMPOSE_FILE:-./docker-compose.yml}"
CONTAINER_WORKSPACE="/workspace"
CONTAINER_ENTRYPOINT="/opt/qualtrics/bee/entrypoint.sh"
CONTAINER_PORTS=
CONTAINER_NATIVE_NET=
CONTAINER_VOLUMES=
CONTAINER_SETUP_SCRIPT=
CONTAINER_NETWORK=
BUILD_ARGUMENTS=
BUILD_ENVIRONMENT=
ABSOLUTE_ROOT_PATH=
HOST_CACHE_PATH=
CONTAINER_CACHE_PATH="/var/tmp/bee.cache"
HOST_IP=

printf "${FMT_YELLOW}"
cat << EOF

                   \     /
              \    o ^ o    /
                \ (     ) /
     ____________(%%%%%%%)____________
    (     /   /  )%%%%%%%(  \   \     )
    (___/___/__/           \__\___\___)
       (     /  /(%%%%%%%)\  \     )
        (__/___/ (%%%%%%%) \___\__)
                /(       )\             Build Environment Executor v${BEE_VERSION}
              /   (%%%%%)   \           gitlab-app.eng.qops.net/core/bee
                   (%%%)
                     !


EOF
printf "${FMT_RESET}"

check_for_updates
printf "\\n\\n"

NAME="$(pwd | sed -E 's/^\/?(.*)$/\1/' | tr '[:upper:]' '[:lower:]' | tr -d '\n')"
printf "Build Name.............................%s\\n" "${NAME}"

DOCKER_CONTAINER_NAME="$(printf '%s' "${NAME}" | sed 's/[^a-zA-Z0-9_-]/_/g')"
DOCKER_INSTANCE_NAME="${DOCKER_CONTAINER_NAME}_${BUILD_ID}"
printf "Build Container Name...................%s\\n" "${DOCKER_INSTANCE_NAME}"

LOCAL_PATH=$(pwd)
printf "Build Location.........................%s\\n" "${LOCAL_PATH}"
printf "Hostname...............................%s\\n" "$(hostname)"
printf "System.................................%s\\n" "$(uname -a)"
printf "Whoami.................................%s\\n" "$(whoami)"

assert_dependencies
printf "System is ready........................yes\\n"

load_all_settings
printf "Loaded custom settings.................ok\\n"
printf "Persisted arguments....................%s\\n" "${BUILD_ARGUMENTS:-n/a}"

# Determine build technology
printf "Build technology......................."
if [[ -n "${DOCKER_IMAGE}" ]]; then
    DOCKER_IMAGE=$(append_paths "${DOCKER_REGISTRY}" "${DOCKER_IMAGE}")
    printf "override by image %s\\n" "${DOCKER_IMAGE}"
else
    if [[ -z "${BUILD_TECH}" ]]; then
        detect_build_tech
    elif [[ -z "${BUILD_TECH_VER}" ]]; then
        printf "${FMT_RED}ERROR${FMT_RESET}: BUILD_TECH override provided without BUILD_TECH_VER\\n"
        exit 1
    fi
    DOCKER_IMAGE=$(append_paths "${DOCKER_REGISTRY}" "core-platform/bee-${BUILD_TECH}:${BUILD_TECH_VER}")
    printf "%s\\n" "${BUILD_TECH}"
fi
printf "Build image............................%s\\n" "${DOCKER_IMAGE}"
printf "Entry point............................%s\\n" "${CONTAINER_ENTRYPOINT}"
printf "Workspace..............................%s\\n" "${CONTAINER_WORKSPACE}"

# Set options for docker environment, network, volumes, user, and other
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'BUILD_INVOKER=${BUILD_TECH}-invoker.sh'"
DOCKER_NETWORK=
DOCKER_VOLUMES=
DOCKER_OPTS=

# Setup user
detect_user
printf "Detected user..........................uid=%s(%s) gid=%s(%s)\\n" "${DOCKER_USER_ID}" "${DOCKER_USER}" "${DOCKER_GROUP_ID}" "${DOCKER_GROUP}"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'USER=${DOCKER_USER}' -e 'USER_ID=${DOCKER_USER_ID}'"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'GROUP=${DOCKER_GROUP}' -e 'GROUP_ID=${DOCKER_GROUP_ID}'"

printf "Running with git configuration........."
if [[ -f "${HOME}/.gitconfig" ]]; then
    DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${HOME}/.gitconfig:/home/${DOCKER_USER}/.gitconfig'"
    DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${HOME}/.gitconfig:/root/.gitconfig'"
    printf "%s\\n" "${HOME}/.gitconfig"
else
    printf "none\\n"
fi

printf "Running with ssh configuration........."
if [[ -d "${HOME}/.ssh" ]]; then
  DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${HOME}/.ssh:/home/${DOCKER_USER}/.ssh'"
  DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${HOME}/.ssh:/root/.ssh'"
  printf "%s\\n" "${HOME}/.ssh"
else
  printf "none\\n"
fi

printf "Detected ssh authentication socket....."
if [[ -n "${SSH_AUTH_SOCK}" ]]; then
    DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'SSH_AUTH_SOCK=/ssh-agent'"
    DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${SSH_AUTH_SOCK}:/ssh-agent'"
    printf "%s\\n" "${SSH_AUTH_SOCK}"
else
    printf "none\\n"
fi

# Configure network settings
determine_ip_address
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'HOST_IP=${HOST_IP}'"
printf "Host IP determined.....................%s\\n" "${HOST_IP}"


printf "Docker communication..................."
determine_docker_comm
if [[ "${?}" == "0" ]]; then
    printf "ok\\n"
else
    printf "no\\n"
fi

DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'BUILD_CONTAINER_NAME=${DOCKER_INSTANCE_NAME}'"

eval "set -- ${CONTAINER_PORTS}"
for p do DOCKER_NETWORK="${DOCKER_NETWORK} -p '${p}'"; done
printf "Exposed ports..........................%s\\n" "${CONTAINER_PORTS:-none}"

printf "Virtualized network...................."
if [[ -n "${CONTAINER_NATIVE_NET}" ]]; then
    DOCKER_NETWORK="${DOCKER_NETWORK} --net=host"
    printf "no\\n"
else
    printf "yes\\n"
fi

# Workspace setup
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'WORKSPACE=${CONTAINER_WORKSPACE}'"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'ABSOLUTE_WORKSPACE=${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}'"
DOCKER_OPTS="${DOCKER_OPTS} -w '${CONTAINER_WORKSPACE}'"
DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${ABSOLUTE_ROOT_PATH}${LOCAL_PATH}:${CONTAINER_WORKSPACE}'"

detect_host_cache_path
printf "Host cache path.......................%s%s\\n" "${ABSOLUTE_ROOT_PATH}" "${HOST_CACHE_PATH}"
DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'CACHE_PATH=${CONTAINER_CACHE_PATH}'"
printf "Container cache path..................%s\\n" "${CONTAINER_CACHE_PATH}"
DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${ABSOLUTE_ROOT_PATH}${HOST_CACHE_PATH}:${CONTAINER_CACHE_PATH}'"

eval "set -- ${CONTAINER_VOLUMES}"
for e do DOCKER_VOLUMES="${DOCKER_VOLUMES} -v '${e}'"; done

# Custom configuration
eval "set -- ${BUILD_ENVIRONMENT}"
for e do DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e '${e}'"; done

printf "Interactive mode......................."
if tty -s; then
    DOCKER_OPTS="${DOCKER_OPTS} -it"
    DOCKER_ENVIRONMENT="${DOCKER_ENVIRONMENT} -e 'INTERACTIVE=1'"
    printf "yes\\n"
else
    printf "no\\n"
fi

docker_clear_state
printf "Clearing docker state..................ok\\n"

eval "set -- ${ARGS_ARRAY}"

# Parse all leading arguments and see if we get a match for a bee parameter.
# As soon as an unknown parameter is found, we will treat it as a pass through to the
# build container.
for arg in "${@}"; do
    case "${arg}" in
        -h|--help)
            shift
            print_usage
            exit $?
            ;;
        -dc|--run-docker-compose)
            shift
            OPT_RUN_DOCKER_COMPOSE=true
            ;;
        -p|--purge)
            shift
            OPT_PURGE=true
            ;;
        -trs|--report-test-results)
            shift
            OPT_REPORT_TEST_RESULTS=true
            ;;
        qamel)
            shift
            qamel "${@}"
            exit $?
            ;;
        config)
            shift
            printf "\\nBee Config:\\n"
            print_config "${@}"
            exit $?
            ;;
        *)
            # As soon as we get an unknown param we start treating it as pass through
            break
            ;;
    esac
done

if [[ -n "${OPT_PURGE}" ]]; then
    docker_clear_state
    docker_clear_setup
    printf "Purging state..........................ok\\n"
fi

docker_run_setup
printf "Docker setup...........................ok\\n"

if [[ -n "${OPT_RUN_DOCKER_COMPOSE}" ]]; then
    docker_start_dependencies
    printf "Docker dependency startup..............ok\\n"
fi

if [[ -n "${CONTAINER_NETWORK}" ]]; then
    DOCKER_NETWORK="${DOCKER_NETWORK} --network=${CONTAINER_NETWORK}"
fi
printf "Network................................%s\\n" "${CONTAINER_NETWORK:-none}"

BUILD_CMD="docker run \
    --name '${DOCKER_INSTANCE_NAME}' \
    ${DOCKER_OPTS} \
    ${DOCKER_NETWORK} \
    ${DOCKER_VOLUMES} \
    ${DOCKER_ENVIRONMENT} \
    ${DOCKER_COMM_OVERRIDE:-$DOCKER_COMM} \
    ${DOCKER_IMAGE} \
    ${CONTAINER_ENTRYPOINT} ${BUILD_ARGUMENTS} ${@}"

printf "\\n%s\\n\\n" "${BUILD_CMD}"
eval "${BUILD_CMD}"
ret=$?
if [[ "${ret}" == "0" ]]; then
    printf "\\nSUCCESS (%d)\\n" "${ret}"

    if [[ -n "${OPT_REPORT_TEST_RESULTS}" ]]; then
        test_result_upload || printf "${FMT_YELLOW}WARN${FMT_RESET}: Test Result Upload Failed\\n"
    fi
else
    printf "\\nFAILURE (%d)\\n" "${ret}"
fi

exit ${ret}
