const fs = require('fs');
const http = require('http');
const path = require('path');
const minimist = require('minimist');

function log(...messages) {
    console.log(new Date(), '-', ...messages);
}

function getTranslations(teamId, appId, data) {
    return new Promise((resolve, reject) => {
        const requestBody = JSON.stringify(data);

        const options = {
            hostname: 'localization.eng.qops.net',
            port: 80,
            path: `/localization/v1/translations?teamId=${teamId}&appId=${appId}`,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
                'Content-Length': requestBody.length,
            },
        };

        const request = http.request(options, response => {
            let responseBody = '';
            response.on('data', data => {
                responseBody += data;
            });
            response.on('end', () => {
                const body = JSON.parse(responseBody);
                resolve(body);
            });
        });
        request.on('error', reject);
        request.write(requestBody);
        request.end();
    });
}

async function mapTranslationFiles(translations, outputPath) {
    Object.entries(translations).forEach(([key, value]) => {
        const content = JSON.stringify(value, null, 2);

        fs.mkdirSync(outputPath, { recursive: true });
        fs.writeFileSync(path.join(outputPath, `${key}.json`), content);
    });
}

function createIndexFile(translationKeys, outputPath) {
    let content = 'module.exports = {\n';
    translationKeys.forEach(translationKey => {
        let key = translationKey;
        if (translationKey.includes('-')) {
            key = `'${translationKey}'`;
        }
        content += `    ${key}: require('./${translationKey}.json'),\n`;
    });
    content += '};\n';

    fs.writeFileSync(path.join(outputPath, 'index.js'), content);
}

async function generate(outputPath, teamId, appId, data) {
    try {
        log('Retrieving translations');
        const translations = await getTranslations(teamId, appId, data);

        log('Outputting translation files to:', outputPath);
        await mapTranslationFiles(translations, outputPath);
        createIndexFile(Object.keys(translations), outputPath);

        log('Success!');
    } catch (err) {
        log('Failed!', err);
    }
}

async function generateFromConfig() {
    const filePath = minimist(process.argv.slice(2)).config || 'i18n.config.js';
    const config = require(path.join(process.cwd(), filePath));
    await generate(config.outputPath, config.teamId, config.appId, config.data);
}

generateFromConfig();
